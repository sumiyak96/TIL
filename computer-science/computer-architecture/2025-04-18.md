# 💻 CS61C Lecture 02.4 – Number Representation: Two’s Complement, Bias, and Summary

---

## 🎯 今回のテーマ / Today's Focus

- Two’s Complement（二の補数）による負の数の表現
- Biased Representation（バイアス表現）の仕組み
- 様々な整数表現の比較と選ばれる理由

---

## ✅ Two’s Complement（二の補数）

### ▸ 特徴 / Features

- **負の数の表現方法として最も一般的**
- 正の数：そのままビットで表現
- 負の数：正のビット列を **反転＋1** して得る
- 全ビットが1（例：`1111`）は **常に -1**

### ▸ メリット / Benefits

- **+0 / -0 の2種類がなく、0は1つだけ**
- 加算・減算を同じ回路で処理できる
- 二進数のオドメーター（連続的なカウント）としても自然

---

## ✅ Biased Representation（バイアス表現）

### ▸ 特徴 / Features

- ビット値に **一定の値（バイアス）を足して保存**
- 保存は unsigned（0以上）でも、**内部的に負の数を含む**

### ▸ 例 / Example

- **バイアス = 15**
  - 実際の値 `-15` → 保存値 `0`
  - 実際の値 `0` → 保存値 `15`
  - 実際の値 `+16` → 保存値 `31`

### ▸ メリット / Benefits

- 正負を均等に分けたいときに便利（例：信号処理）
- ビット列が常に増加方向に進む（-15 → -14 → ... → 0 → +1）

---

## 🆚 表現方法の比較

| 表現方式              | 範囲（nビット）          | メリット                         | デメリット                      |
|-----------------------|--------------------------|----------------------------------|---------------------------------|
| Unsigned              | 0 ～ 2ⁿ−1               | 単純で高速                       | 負の数が扱えない                |
| Sign and Magnitude    | -(2ⁿ⁻¹−1) ～ +(2ⁿ⁻¹−1) | 人にとって直感的                | +0/-0 が2種類、演算が複雑      |
| One’s Complement      | 同上                     | ビット反転だけで負数が得られる | +0/-0 が2種類、演算が複雑      |
| **Two’s Complement**  | -2ⁿ⁻¹ ～ 2ⁿ⁻¹−1         | **加減算が簡単、0が1種類**      | 正の最大値がやや小さい          |
| Biased                | 任意（例: -15 ～ +16）   | 中心を0にできて便利              | 誤解を防ぐにはバイアスの共有が必要 |

---

## 🧠 Takeaways

- ✅ **実際のソフトウェアやハードウェアでは、Two’s Complementが基本**
- ✅ **バイアス表現は特定の分野（信号・画像処理など）で使われる**
- ✅ **すべての表現には「設計の意図」があり、用途に応じて使い分ける**

---

## 🔜 次回のテーマ / Coming Up Next

- C言語での整数型（int, uint）と実際の扱われ方
- Number representation をどうプログラムに落とし込むか

