# 💻 CS61C Lecture 03.1 & 03.2 – C言語入門：背景・仕組み・実行の流れ

---

## 🌟 今回のテーマ / Today's Focus

- なぜ今C言語を学ぶのか？
- コンパイルとインタプリタの違い
- Cプログラムのビルドフロー
- Cプリプロセッサとマクロの基本

---

## ✅ なぜCを学ぶのか？

### ▹ 歴史と背景

- UNIX OSがCで書かれたことで、移植可能なOSが実現
- アーキテクチャを深く理解するのに最適な「低レベル言語」
- 40年以上にわたり使われ続ける普遍的なプログラミング言語

### ▹ 教育的価値

- メモリ構造、ポインタ、アドレス操作を学べる
- JavaやPythonとは異なる低レベル視点での思考が要求される
- 抽象化と設計判断（例：安全性 vs 性能）の理解が深まる

---

## ✅ コンパイルとインタプリタの違い

| 項目         | コンパイル型（例：C）                     | インタプリタ型（例：Python）                   |
|--------------|-------------------------------------------|------------------------------------------------|
| 実行方法     | 実行前に機械語に変換                     | 実行時に逐次解釈                              |
| 実行速度     | 非常に高速（直接CPUで動作）             | 比較的遅い（都度解釈）                         |
| デバッグ性   | コンパイル・リンクが必要で手間           | すぐに試せる（REPLなど）                       |
| 移植性       | 実行ファイルは機種依存                   | 多くは機種非依存（例：Javaバイトコード）       |
| 利用例       | OS、組み込み、システム制御               | スクリプト、AI、データ分析など                 |

---

## ✅ Cプログラムのビルドフロー

1. `foo.c`, `bar.c` など複数の `.c` ファイルをそれぞれ **コンパイル**
   - → `foo.o`, `bar.o` などの **オブジェクトファイル**に変換
2. `.o` ファイルと必要なライブラリを **リンク**
   - → `a.out` のような **実行ファイル**が生成される

### ▹ Makefile のメリット

- 変更があった `.c` ファイルだけを再コンパイル
- 大規模プロジェクトではビルド効率が格段に上がる

---

## ✅ Cプリプロセッサとマクロ

### ▹ プリプロセッサ命令

- `#include`：ヘッダーファイルを展開
- `#define`：定数やマクロの定義
- `#ifdef`, `#endif`：条件付きコンパイルに使う

### ▹ マクロの落とし穴

```c
#define MIN(x, y) ((x) < (y) ? (x) : (y))
```

- 副作用のある関数呼び出し（例：`MIN(foo(), bar())`）では、`foo()` や `bar()` が複数回呼ばれることがある
- 単なるテキスト置換なので、関数のような「1回だけの評価」が保証されない

---

## 🧐 Takeaways

- ✅ Cは「コンピュータを意識した」低レイヤープログラミングが可能な貴重な言語
- ✅ 実行の速さ・制御性に優れるが、安全性や移植性では難がある
- ✅ マクロやプリプロセッサ、ビルドフローなど、C特有の仕組みに慣れることが重要

---

## 💜 次回のテーマ / Coming Up Next

- Cの基本文法（型、関数、制御構文など）
- メモリ管理とポインタの実践的な活用法

