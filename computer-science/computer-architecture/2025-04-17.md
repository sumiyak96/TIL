# 📘 CS61C Lecture 02.3 - Number Representation: Overflow, Sign and Magnitude, One’s Complement

---

## 🧠 今日の学び

### 🎯 テーマ：負の数の表現とオーバーフローの理解

- ビット列は「数そのもの」ではなく、「数の表現（numeral）」である
- ビット数が足りずに数値が範囲を超えた場合、**オーバーフロー（overflow）** が発生
- 負の数を表現する方法として、以下3つの方式がある（本講義では最初の2つを紹介）

---

## 🔁 オーバーフロー（Overflow）

- **定義**：ビット数が固定された中で計算し、最大値を超えた結果が「ゼロや小さな値」に巻き戻ること
- 例（5ビット）：
  - `11111₂ = 31₁₀`
  - `11111 + 1 = 00000`（= 0）→ overflow!

- **引き算でも発生**：0から1を引くと `11111` に戻る → これも overflow（※ underflow ではない）

---

## ➖ 負の数の表現方法

### ✅ 方法①：Sign and Magnitude（符号と絶対値）

- 最上位ビット（MSB）を符号ビットとし、残りで値を表現
  - `0xxxx` = 正の数
  - `1xxxx` = 負の数（同じ値の絶対値）
- 例：5ビット
  - `01001` = +9
  - `11001` = -9
- 問題点：
  - `+0` と `-0` の **2種類のゼロ**
  - 正負の混在により演算回路が複雑
  - バイナリカウンター（odometer）での値の増加が不自然

---

### ✅ 方法②：One’s Complement（1の補数）

- 負の数 = 正の数のビットをすべて反転（1と0を逆に）
  - `+7 = 00000111`
  - `-7 = 11111000`
- 特徴：
  - 負の数の先頭ビットは常に `1`（直感的にわかりやすい）
  - 正数は先頭が `0`
- 問題点：
  - **やはり `+0` と `-0` の2つのゼロが存在**
  - 計算がやや複雑で、ハードウェア実装に向かない

---

## ✋ バイナリオドメーター（指で2進数を表す）

- 指を `2⁰, 2¹, 2²...` に割り当てて、0〜31を数える例で説明
- **Sign and Magnitude や One’s Complement では**、値が「正→負」へ急に変化してしまい不自然

---

## ✅ まとめ

| 表現方式 | 特徴 | 問題点 |
|-----------|------|--------|
| **Unsigned（符号なし）** | 0〜最大値だけ扱える | 負の数が扱えない |
| **Sign and Magnitude** | MSBが符号、残りが絶対値 | +0と-0が存在、演算が複雑 |
| **One’s Complement** | 負 = ビット反転 | +0と-0が存在、加算が難しい |

---

## ⏭ 次回予告

- 次回は **Two’s Complement（二の補数）**
- 現代のコンピュータで最も一般的な「負の数の表現方法」

